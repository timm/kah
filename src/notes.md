why not found?

- poor emirical track record (deep learning paper)
- not enough data to explore (now we have moot)
- all too  willing to accept methods from AI without reviewing them critically
- no one thought to check and exploit what is unique about se artifacts (follow the leader, 

why did it work?

<!-- What you're describing sounds like preferential attachment or the rich-get-richer effect, which is closely related to power law distributions and exponential growth dynamics. This mechanism often shows up in networks, social systems, and exploratory algorithms. -->
<!--  -->
<!-- In essence: -->
<!--  -->
<!-- Few nodes get most of the attention (or connections). -->
<!-- The more explored/connected something is, the more likely it is to attract even more exploration/connection. -->
<!-- This isn't quite Zipf's Law (which deals with rank-frequency distributions) but aligns with concepts like: -->
<!--  -->
<!-- Yule Process (from biology/ecology). -->
<!-- Barabási–Albert Model (scale-free networks). -->
<!-- Matthew Effect ("the rich get richer"). -->
<!-- In algorithms or exploratory systems, this can lead to positive feedback loops where "popular" choices dominate over time, reinforcing their selection. -->
<!--  -->
<!-- Would this concept fit the pattern you're observing? -->


how mahrd can it be to do multi object optimizatipn
- competing
    - lots of nuaces

- holland vs chen mutation

        Scientific Amer...
Vol. 267, No. 1...
Cover of Scientific American
Vol. 267, No. 1, JULY 1992
Scientific American
Published by: Scientific American, a division of Nature America, Inc.
https://www.jstor.org/stable/e24939119

https://royalsociety.org/-/media/policy/projects/science-in-the-age-of-ai/science-in-the-age-of-ai-report.pdf
-- small data
-- reprodcuability (used to demain report priot experiemtns. now we read the values
   in papers written by the authrors.

Ever worry that our AI systems are 

tdd: always leave one bug for tomorrow, so you can swapa in faster

se is more than coding. personne;, product, process. some langauge features enable things that would be impossible otheriwsea be ahrd. e.g. erlang

objects
	facories (creation)
	polymorohism

standard strcture

/.github/workflows
/docs
/etc
    /dotshellrc
    /dotedtitrc 
    /head.html
    other e.g.
       /lua.ssh
/src
    /Makefile

shell
    hello (colors)
    aliases
    short cuts
    promopt control

makefile
    e.g. menu sh

treating code as a meta resource. code does not jsut run. it a resoruce that
can offer multiple srcies. documetaton. texting, a whol
erange of different functions.

FQ:
- how do i divide things into modules
- for how selctively import
    - how do do comamnd line
        - how to do test suite
            - messpace management. static code checking?
                

curse of the model:
if you drove her today baset a  speed limit sign you saw the output
of some risk model that decide fr all cars and all drivers a ssped
limit of say 65 was fine. really? one limit for all driers? now
matter what is their age, experience i driving car, urgency of thei
mission, weather conditions, etc etc.
dont want some trite summary for all. want what is right for me (perhas with some modifier that i do not diminish others who come in contact with me).


manage your namespace, bunc together related functions into a few tables,
check for rogue locals.

to work bash pipes in, out of the box,. lua reads fro stdin.
so this is easy

cat ../../data/auto93.csv| ./nb.lua --csv

 to work pipls in oo. retrunr self a lot
vscode a static code analyzer of vscode

the __name__== "__main__" trick in lua
